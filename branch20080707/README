READ ME FOR ISSUE 60 BRANCH

This branch is intended to document the incremental changes required for one possible solution to Issue 58, Issue 59, Issue 60, and Issue 61.

BACKGROUND

In particular Issue 58 is crashing because multiple threads can be spawned that try to simultaneously parse the Lightroom library.

Issue 59 is a restatement of Issue 58 and includes a potential patch to fix the immediate problem, but not the long term problem.

Issue 60 describes the broken file watching mechanism.

Issue 61 requests a performance improvement.

DESIGN PLAN

The design proposed in this branch is to separate the parsing of the libraries from the displaying of the views. In this way, multiple
views can re-use the same library parsing legwork. In addition, we can implement thread safe access to the library parsers. And finally,
we can centralize and extend the handling of file watchers.

In the trunk (r603), the views iterate through the list of parsers suitable for their data type (for instance, the music view will
iterate through each music parser. Each parser returns a list of iLibraryNodes and the view puts those together into a master list and
displays it. The parser code contains non-working code to watch for file changes, cache the iLibraryNodes, and notify the "owner" of
the parser about changes.

The problem with this technique is that the parsers are not shared between views. Each view has its own parser. In addition, the non-working
code to watch for file changes, cache the library nodes, and notify the parser's _owner_ pollute the nature of the parser -- namely to
parse the libraries and generate a list of library nodes.

In this branch, however, the management of the library nodes will be separated from the views. Instead, the view will ask the "parser controller"
for a binding to the list of library nodes. In this way, each view of the same type (i.e. all music views) will share the same list of
library nodes. In addition, thread safety, file watching, and other changes to the list can be managed in a centralized class.

In addition, when the first view of a specific type asks for a list of library nodes, the nodes will be constructed in the background in
simultaneous threads. Right now, the nodes are constructed sequentially in a single thread. This will result in almost immediate display
of each library type (similar to how the music type happens now). In the background, the library nodes will continue to be constructed
and new items will be added as they are built.

DESIGN LIMITATIONS

Different views of the same type will share the master list of library nodes. If different views want to have different views of the data,
some new mechanism will have to be implemented to filter the master list.

IMPLEMENTATION PLAN

The implementation plan is to first simplify the parser classes so that they are purely used for parsing libraries. Any caching or file
watching functionality will be removed from the parser. It will later be moved into a different controller class (probably iMediaConfiguration).
In addition to removing the file watcher and caching, the 'myBrowser' instance variable can also be removed since it will no longer be
used and represents a breaking of the "pure parser" idea.

Next the management of the iLibraryNodes (i.e. "parser controller") will move from the iMBAbstractView class to iMediaConfiguration. iMediaConfiguration seems like a
good place to put it for now, but that might not be the final resting place for the "parser controller".

Next all of the node parsing will be moved to background threads. See the current way that populateLibraryNode works for more information about this.

Finally, file watcher functionality can be added into the "parser controller" so that it watches for changes to the library and for changes to specific
photos. (This may obviate the need for the 'refresh' button in the long run).
